{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar resolve = require( '@stdlib/strided-base-dtype-resolve-str' );\nvar Complex64 = require( '@stdlib/complex-float32-ctor' );\nvar Complex128 = require( '@stdlib/complex-float64-ctor' );\nvar wrap = require( '@stdlib/complex-base-cast-return' );\n\n\n// VARIABLES //\n\nvar C64 = 'complex64';\nvar C128 = 'complex128';\nvar CTORS = {\n\t'complex64': Complex64,\n\t'complex128': Complex128\n};\n\n\n// FUNCTIONS //\n\n/**\n* Resolves a callback based on provided dtypes.\n*\n* @private\n* @param {Object} table - callback table\n* @param {Function} table.default - default callback\n* @param {Function} table.complex64 - callback for single-precision complex floating-point numbers\n* @param {Function} table.complex128 - callback for double-precision complex floating-point numbers\n* @param {string} t1 - dtype for input argument\n* @param {string} t2 - dtype for return value\n* @returns {Function} callback\n*/\nfunction resolveCallback( table, t1, t2 ) {\n\t// Signature: ?_z\n\tif ( t2 === C128 ) {\n\t\t// c_z or z_z\n\t\tif ( t1 === C64 || t1 === C128 ) {\n\t\t\t// Always perform computation in higher precision:\n\t\t\treturn table[ C128 ];\n\t\t}\n\t\t// d_z (cast the double-precision return value from `d_d` to a complex number)\n\t\treturn wrap( table.default, 1, CTORS[ t2 ] );\n\t}\n\t// Signature: ?_c\n\tif ( t2 === C64 ) {\n\t\t// c_c\n\t\tif ( t1 === C64 ) {\n\t\t\treturn table[ C64 ];\n\t\t}\n\t\t// z_c\n\t\tif ( t1 === C128 ) {\n\t\t\t// Always perform the computation in higher precision:\n\t\t\treturn table[ C128 ];\n\t\t}\n\t\t// d_c (cast the double-precision return value from `d_d` to a complex number)\n\t\treturn wrap( table.default, 1, CTORS[ t2 ] );\n\t}\n\t// Signature: ?_o\n\tif ( t2 === 'generic' ) {\n\t\t// z_o\n\t\tif ( t1 === C128 ) {\n\t\t\treturn table[ C128 ]; // Signature: z_o_as_z_z\n\t\t}\n\t\t// c_o\n\t\tif ( t1 === C64 ) {\n\t\t\treturn table[ C64 ]; // Signature: c_o_as_c_c\n\t\t}\n\t\t// d_o\n\t\treturn table.default; // Signature: d_o_as_d_d\n\t}\n\treturn table.default;\n}\n\n\n// MAIN //\n\n/**\n* Assigns callbacks to masked unary interfaces according to type promotion rules.\n*\n* ## Notes\n*\n* -   The function assumes that the provided signature array has the following properties:\n*\n*     -   a strided array having a stride length of `3` (i.e., every `3` elements define a masked unary interface signature).\n*     -   for each signature (i.e., set of three consecutive non-overlapping strided array elements), the first element is the input data type, the second element is the mask data type, and the last element is the return data type.\n*     -   all signatures (excluding the mask data type) follow type promotion rules.\n*\n* -   Based on type promotion rules, we can simply use the callback for `float64` (i.e., the assumed \"default\") for all interfaces not involving complex numbers, even for `float32`, as we shouldn't need to explicitly downcast strided array values. The only time we need to return `float32` values is when input arrays are already `float32` or of a type which can be safely represented in `float32` without concern for truncation.\n*\n* @param {Object} table - callback table\n* @param {Function} table.default - default callback\n* @param {Function} table.complex64 - callback for single-precision complex floating-point numbers\n* @param {Function} table.complex128 - callback for double-precision complex floating-point numbers\n* @param {ArrayLikeObject} signatures - strided array containing masked unary interface signatures\n* @returns {Array<Function>} list of callbacks\n*\n* @example\n* var signatures = require( '@stdlib/strided-base-mskunary-dtype-signatures' );\n* var identity = require( '@stdlib/number-float64-base-identity' );\n* var cidentity = require( '@stdlib/complex-float64-base-identity' );\n* var cidentityf = require( '@stdlib/complex-float32-base-identity' );\n*\n* var dtypes = [\n*     'float64',\n*     'float32',\n*     'int32',\n*     'uint8'\n* ];\n*\n* var sigs = signatures( dtypes, dtypes );\n* // returns [...]\n*\n* var table = {\n*     'default': identity,\n*     'complex64': cidentityf,\n*     'complex128': cidentity\n* };\n*\n* var list = callbacks( table, sigs );\n* // returns [...]\n*/\nfunction callbacks( table, signatures ) {\n\tvar out;\n\tvar t1;\n\tvar t2;\n\tvar i;\n\n\tout = [];\n\tfor ( i = 0; i < signatures.length; i += 3 ) {\n\t\tt1 = resolve( signatures[ i ] );\n\t\tt2 = resolve( signatures[ i+2 ] );\n\t\tout.push( resolveCallback( table, t1, t2 ) );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = callbacks;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Assign callbacks to masked unary interfaces according to type promotion rules.\n*\n* @module @stdlib/strided-base-mskunary-signature-callbacks\n*\n* @example\n* var signatures = require( '@stdlib/strided-base-mskunary-dtype-signatures' );\n* var identity = require( '@stdlib/number-float64-base-identity' );\n* var cidentity = require( '@stdlib/complex-float64-base-identity' );\n* var cidentityf = require( '@stdlib/complex-float32-base-identity' );\n* var callbacks = require( '@stdlib/strided-base-mskunary-signature-callbacks' );\n*\n* var dtypes = [\n*     'float64',\n*     'float32',\n*     'int32',\n*     'uint8'\n* ];\n*\n* var sigs = signatures( dtypes, dtypes );\n* // returns [...]\n*\n* var table = {\n*     'default': identity,\n*     'complex64': cidentityf,\n*     'complex128': cidentity\n* };\n*\n* var list = callbacks( table, sigs );\n* // returns [...]\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAU,QAAS,wCAAyC,EAC5DC,EAAY,QAAS,8BAA+B,EACpDC,EAAa,QAAS,8BAA+B,EACrDC,EAAO,QAAS,kCAAmC,EAKnDC,EAAM,YACNC,EAAO,aACPC,EAAQ,CACX,UAAaL,EACb,WAAcC,CACf,EAiBA,SAASK,EAAiBC,EAAOC,EAAIC,EAAK,CAEzC,OAAKA,IAAOL,EAENI,IAAOL,GAAOK,IAAOJ,EAElBG,EAAOH,CAAK,EAGbF,EAAMK,EAAM,QAAS,EAAGF,EAAOI,CAAG,CAAE,EAGvCA,IAAON,EAENK,IAAOL,EACJI,EAAOJ,CAAI,EAGdK,IAAOJ,EAEJG,EAAOH,CAAK,EAGbF,EAAMK,EAAM,QAAS,EAAGF,EAAOI,CAAG,CAAE,EAGvCA,IAAO,UAEND,IAAOJ,EACJG,EAAOH,CAAK,EAGfI,IAAOL,EACJI,EAAOJ,CAAI,EAGZI,EAAM,QAEPA,EAAM,OACd,CAkDA,SAASG,EAAWH,EAAOI,EAAa,CACvC,IAAIC,EACAJ,EACAC,EACAI,EAGJ,IADAD,EAAM,CAAC,EACDC,EAAI,EAAGA,EAAIF,EAAW,OAAQE,GAAK,EACxCL,EAAKT,EAASY,EAAYE,CAAE,CAAE,EAC9BJ,EAAKV,EAASY,EAAYE,EAAE,CAAE,CAAE,EAChCD,EAAI,KAAMN,EAAiBC,EAAOC,EAAIC,CAAG,CAAE,EAE5C,OAAOG,CACR,CAKAd,EAAO,QAAUY,ICzGjB,IAAII,EAAO,IAKX,OAAO,QAAUA",
  "names": ["require_main", "__commonJSMin", "exports", "module", "resolve", "Complex64", "Complex128", "wrap", "C64", "C128", "CTORS", "resolveCallback", "table", "t1", "t2", "callbacks", "signatures", "out", "i", "main"]
}
