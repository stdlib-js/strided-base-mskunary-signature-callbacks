{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport resolve from '@stdlib/strided-base-dtype-resolve-str';\nimport Complex64 from '@stdlib/complex-float32-ctor';\nimport Complex128 from '@stdlib/complex-float64-ctor';\nimport wrap from '@stdlib/complex-base-cast-return';\n\n\n// VARIABLES //\n\nvar C64 = 'complex64';\nvar C128 = 'complex128';\nvar CTORS = {\n\t'complex64': Complex64,\n\t'complex128': Complex128\n};\n\n\n// FUNCTIONS //\n\n/**\n* Resolves a callback based on provided dtypes.\n*\n* @private\n* @param {Object} table - callback table\n* @param {Function} table.default - default callback\n* @param {Function} table.complex64 - callback for single-precision complex floating-point numbers\n* @param {Function} table.complex128 - callback for double-precision complex floating-point numbers\n* @param {string} t1 - dtype for input argument\n* @param {string} t2 - dtype for return value\n* @returns {Function} callback\n*/\nfunction resolveCallback( table, t1, t2 ) {\n\t// Signature: ?_z\n\tif ( t2 === C128 ) {\n\t\t// c_z or z_z\n\t\tif ( t1 === C64 || t1 === C128 ) {\n\t\t\t// Always perform computation in higher precision:\n\t\t\treturn table[ C128 ];\n\t\t}\n\t\t// d_z (cast the double-precision return value from `d_d` to a complex number)\n\t\treturn wrap( table.default, 1, CTORS[ t2 ] );\n\t}\n\t// Signature: ?_c\n\tif ( t2 === C64 ) {\n\t\t// c_c\n\t\tif ( t1 === C64 ) {\n\t\t\treturn table[ C64 ];\n\t\t}\n\t\t// z_c\n\t\tif ( t1 === C128 ) {\n\t\t\t// Always perform the computation in higher precision:\n\t\t\treturn table[ C128 ];\n\t\t}\n\t\t// d_c (cast the double-precision return value from `d_d` to a complex number)\n\t\treturn wrap( table.default, 1, CTORS[ t2 ] );\n\t}\n\t// Signature: ?_o\n\tif ( t2 === 'generic' ) {\n\t\t// z_o\n\t\tif ( t1 === C128 ) {\n\t\t\treturn table[ C128 ]; // Signature: z_o_as_z_z\n\t\t}\n\t\t// c_o\n\t\tif ( t1 === C64 ) {\n\t\t\treturn table[ C64 ]; // Signature: c_o_as_c_c\n\t\t}\n\t\t// d_o\n\t\treturn table.default; // Signature: d_o_as_d_d\n\t}\n\treturn table.default;\n}\n\n\n// MAIN //\n\n/**\n* Assigns callbacks to masked unary interfaces according to type promotion rules.\n*\n* ## Notes\n*\n* -   The function assumes that the provided signature array has the following properties:\n*\n*     -   a strided array having a stride length of `3` (i.e., every `3` elements define a masked unary interface signature).\n*     -   for each signature (i.e., set of three consecutive non-overlapping strided array elements), the first element is the input data type, the second element is the mask data type, and the last element is the return data type.\n*     -   all signatures (excluding the mask data type) follow type promotion rules.\n*\n* -   Based on type promotion rules, we can simply use the callback for `float64` (i.e., the assumed \"default\") for all interfaces not involving complex numbers, even for `float32`, as we shouldn't need to explicitly downcast strided array values. The only time we need to return `float32` values is when input arrays are already `float32` or of a type which can be safely represented in `float32` without concern for truncation.\n*\n* @param {Object} table - callback table\n* @param {Function} table.default - default callback\n* @param {Function} table.complex64 - callback for single-precision complex floating-point numbers\n* @param {Function} table.complex128 - callback for double-precision complex floating-point numbers\n* @param {ArrayLikeObject} signatures - strided array containing masked unary interface signatures\n* @returns {Array<Function>} list of callbacks\n*\n* @example\n* import signatures from '@stdlib/strided-base-mskunary-dtype-signatures';\n* import identity from '@stdlib/number-float64-base-identity';\n* import cidentity from '@stdlib/complex-float64-base-identity';\n* import cidentityf from '@stdlib/math-base-special-cidentityf';\n*\n* var dtypes = [\n*     'float64',\n*     'float32',\n*     'int32',\n*     'uint8'\n* ];\n*\n* var sigs = signatures( dtypes, dtypes );\n* // returns [...]\n*\n* var table = {\n*     'default': identity,\n*     'complex64': cidentityf,\n*     'complex128': cidentity\n* };\n*\n* var list = callbacks( table, sigs );\n* // returns [...]\n*/\nfunction callbacks( table, signatures ) {\n\tvar out;\n\tvar t1;\n\tvar t2;\n\tvar i;\n\n\tout = [];\n\tfor ( i = 0; i < signatures.length; i += 3 ) {\n\t\tt1 = resolve( signatures[ i ] );\n\t\tt2 = resolve( signatures[ i+2 ] );\n\t\tout.push( resolveCallback( table, t1, t2 ) );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default callbacks;\n"],"names":["C64","C128","CTORS","complex64","Complex64","complex128","Complex128","resolveCallback","table","t1","t2","wrap","default","callbacks","signatures","out","i","length","resolve","push"],"mappings":";;0YA8BA,IAAIA,EAAM,YACNC,EAAO,aACPC,EAAQ,CACXC,UAAaC,EACbC,WAAcC,GAkBf,SAASC,EAAiBC,EAAOC,EAAIC,GAEpC,OAAKA,IAAOT,EAENQ,IAAOT,GAAOS,IAAOR,EAElBO,EAAOP,GAGRU,EAAMH,EAAMI,QAAS,EAAGV,EAAOQ,IAGlCA,IAAOV,EAENS,IAAOT,EACJQ,EAAOR,GAGVS,IAAOR,EAEJO,EAAOP,GAGRU,EAAMH,EAAMI,QAAS,EAAGV,EAAOQ,IAG3B,YAAPA,EAECD,IAAOR,EACJO,EAAOP,GAGVQ,IAAOT,EACJQ,EAAOR,GAGRQ,EAAMI,QAEPJ,EAAMI,OACd,CAkDA,SAASC,EAAWL,EAAOM,GAC1B,IAAIC,EACAN,EACAC,EACAM,EAGJ,IADAD,EAAM,GACAC,EAAI,EAAGA,EAAIF,EAAWG,OAAQD,GAAK,EACxCP,EAAKS,EAASJ,EAAYE,IAC1BN,EAAKQ,EAASJ,EAAYE,EAAE,IAC5BD,EAAII,KAAMZ,EAAiBC,EAAOC,EAAIC,IAEvC,OAAOK,CACR"}